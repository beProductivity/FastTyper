"use client"
import './game.scss';
import 'public/assets/keyboard-theme/index.scss';
import Keyboard from "react-simple-keyboard";
import { Component, useState, useRef, useEffect } from 'react';
import GenerateGameTextContent from '@/utils/GameEngine/GenerateGameTextContent';
import { Userbanner, Technicbanner, Speedometer, PlayerRecord } from '@/components/game';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { faPlay } from '@fortawesome/free-solid-svg-icons';
import { myGame } from '@/utils/StartGame';
import { useSelector } from 'react-redux';
import { RootState } from '@/redux/store';

export default function Game()
{
  
  
    /*disabled buttons */
    const DisabledKeys:string[] = ["F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8","F9","F10","F11","F12", "Shift", "Control", "Alt","Enter", "CapsLock", "Tab", "Escape", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Delete", "Home", "End", "PageUp", "PageDown"]; 
     /*Text in text area */
    const [WriteText, setWriteText] = useState<string>("");
    /*Text generated by GameContent */
    const [displayedText, setDisplayedText] = useState<string>("Press button Start to START");
   
    /*Change keyboard theme */
    const ThemeKeyboardList:string[] = ['hg-theme-neongreen', 'hg-theme-default', 'hg-theme-classicblack', 'hg-theme-red', 'hg-theme-aestheticwhite']
    const [themeKeyboard, setThemeKeyboard] = useState<string>();
    
    /*Color of text in text area */
    const [TxtColorStyle, setTxtColorStyle ] = useState<string>("txtArea_Red");
   
    /*Game Status */
    const GameIsStarted= useSelector((state: RootState)=> state.GameMode.GameIsStarted);
    /*To Word system */
    const [wordCounter, setWordCounter] = useState<number>(0);
    
    const GameSession = new myGame();
    const AllWords = useSelector((state: RootState)=> state.Words.words);
    const [maxWords, setMaxWords] = useState<number>(0);
    

    useEffect(() => {
      GameSession.GenerateWords()
    }, [])
    const checkCompatibility = ()=> {
      if(displayedText.includes(WriteText)) {
            setTxtColorStyle("txtArea_Green")
       }
       else {
        setTxtColorStyle("txtArea_Red")
       }
       
    }

    const StartGame = async () => {
         GameSession.Play();
         setDisplayedText(AllWords[0][1] as string);
         setMaxWords(AllWords[0].length)
         
    }
    useEffect(() => {
        // Funkcja obsługująca zdarzenie klawiatury
        const handleKeyPress = (event: KeyboardEvent) => {
          if (!DisabledKeys.includes(event.key)) {

            var textarea:any = document.getElementById('textarea_id');
            textarea.scrollTop = textarea.scrollHeight; /*To dziala, scrolluje textarea */

            const targetButton = document.querySelector('[data-skbtn="' + event.key.toString() + '"]');
            targetButton?.classList.add("hg-activeButton");
            setTimeout(() => {
              targetButton?.classList.remove("hg-activeButton");
            }, 100);

          if(GameIsStarted) { 
              if(event.key == "Backspace")
              {
                setWriteText(prevWriteText => prevWriteText.substring(0, prevWriteText.length - 1));
              } else {

              setWriteText(prevWriteText => prevWriteText + event.key);
            }
          } 

        }
       
           
        };
    
        // nasłuchiwanie na zdarzenie klawiatury przy montażu komponentu
        window.addEventListener('keydown', handleKeyPress);
    
        // Funkcja zwrotna czyszcząca nasłuchiwanie przy demontażu komponentu
        return () => {
          window.removeEventListener('keydown', handleKeyPress);
        };
      }, [GameIsStarted]);

    

          /* DELETE @/.com button */
      useEffect(() => {
        document.querySelector('[data-skbtn=".com"]')?.remove();
        document.querySelector('[data-skbtn="@"]')?.remove();

      }, [themeKeyboard])


      useEffect(()=> {
        if(WriteText === displayedText && wordCounter != AllWords[0].length)
        {
          setWordCounter(wordCounter+ 1);
          setDisplayedText(AllWords[0][wordCounter] as string);
          setWriteText("")
        } else if(WriteText === displayedText && wordCounter === AllWords[0].length) {
            GameSession.Stop();
            setWriteText("");
        }
        
      }, [WriteText])

     setTimeout(()=>{
        checkCompatibility();
      }, 10)
    
    return(
    <div className='screen'>
       <div className='game'> 
        <span className='hr'/>
        <Userbanner timerIsOn={GameIsStarted}/>
        <div className='gamePanel'>
          <div></div>
           <Speedometer maxWords={maxWords} actualPoint={wordCounter}/>
           <div><PlayerRecord trigger={GameIsStarted}/></div>
        </div>
        <div className='display_words'>
            {GameIsStarted 
              ?<h1>{displayedText}</h1>
              :<button onClick={StartGame} className='StartButton'><FontAwesomeIcon icon={faPlay} /> START GAME</button>}
        </div>
           <textarea defaultValue={WriteText} id="textarea_id" className={TxtColorStyle} readOnly/>
           <div className='keyboard'>
                <Keyboard
                    layoutName={"default"}
                    theme={themeKeyboard}
                   />
            </div>
            <br/>
            <Technicbanner/>
       </div>
    </div>)
}




/* 

      Theme:
                <select
                        value={themeKeyboard}
                        onChange={e => setThemeKeyboard(e.target.value)}>
                        {ThemeKeyboardList.map(o => (
                          <option key={o} value={o}>{o}</option>
                        ))}
              </select>  */